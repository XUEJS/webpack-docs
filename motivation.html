<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description" content="">
		<meta name="author" content="">
		<link rel="icon" type="image/png" href="/assets/favicon.png" />
		<link rel="stylesheet" href="css/doc.css" />
		<title>motivation</title>
	</head>
	<body>
		<script src="js/doc.js" charset="utf-8" async></script>
		<div class="container">
			<div class="row">
				<div class="col-md-3 nav">

					<div class="logo">
	<ul class="cube-inner">
		<li class="front"><li class="back"><li class="right"><li class="left"><li class="top"><li class="bottom">
	</ul>
	<ul class="cube">
		<li class="front"><li class="back"><li class="right"><li class="left"><li class="top"><li class="bottom">
		<li class="floor">
	</ul>
</div>
<div class="name">webpack</div>
<div class="tagline">MODULE BUNDLER</div>


					<div class="sidebar">
						<ul><li><a href=".">Home</a></li></ul>
						<ul>
<li>入门<ul>
<li><a href="motivation.html">动机</a></li>
<li><a href="what-is-webpack.html">什么是的WebPack？</a></li>
<li><a href="installation.html">安装</a></li>
<li><a href="usage.html">用法</a></li>
<li>Require Modules</li>
<li>Vendor Modules</li>
<li><a href="using-loaders.html">使用加载器</a></li>
<li><a href="using-plugins.html">使用插件</a></li>
<li><a href="dev-tools.html">开发工具</a></li>
<li><a href="troubleshooting.html">故障排除</a></li>
</ul>
</li>
<li>教程与示例<ul>
<li><a href="http://webpack.github.io/docs/tutorials/getting-started/">入门</a></li>
<li><a href="list-of-tutorials.html">教程列表</a></li>
<li><a href="examples.html">示例</a></li>
</ul>
</li>
<li>指南<ul>
<li><a href="commonjs.html">CommonJs</a></li>
<li><a href="amd.html">AMD</a></li>
<li><a href="webpack-for-browserify-users.html">Browserify 用户</a></li>
<li><a href="code-splitting.html">代码分割</a></li>
<li><a href="stylesheets.html">样式表</a></li>
<li><a href="optimization.html">优化</a></li>
<li><a href="long-term-caching.html">长期缓存</a></li>
<li><a href="how-to-write-a-loader.html">如何写一个加载器</a></li>
<li>如何写一个插件(How to write a plugin)</li>
<li><a href="multiple-entry-points.html">多个入口点</a>(Multiple entry points)</li>
<li><a href="library-and-externals.html">库和扩展</a>(Library and externals)</li>
<li><a href="shimming-modules.html">垫片模块</a>(Shimming modules)</li>
<li><a href="testing.html">测试</a></li>
<li><a href="build-performance.html">构建性能</a></li>
<li><a href="hot-module-replacement-with-webpack.html">模块热替换</a>(Hot Module Replacement with webpack)</li>
<li><a href="comparison.html">比较</a></li>
</ul>
</li>
<li>webpack 相关<ul>
<li><a href="usage-with-grunt.html">使用 Grunt</a></li>
<li><a href="usage-with-gulp.html">使用 Gulp</a></li>
<li><a href="usage-with-bower.html">使用 Bower</a></li>
<li><a href="usage-with-karma.html">使用 Karma</a></li>
</ul>
</li>
<li>列表<ul>
<li><a href="loader-conventions.html">加载器约定</a></li>
<li><a href="list-of-loaders.html">加载器列表</a></li>
<li><a href="list-of-plugins.html">插件列表</a></li>
<li><a href="list-of-tutorials.html">教程列表</a></li>
</ul>
</li>
<li>API<ul>
<li><a href="configuration.html">构造</a></li>
<li><a href="cli.html">CLI</a></li>
<li><a href="node.js-api.html">Node.js API</a></li>
<li><a href="api-in-modules.html">API in modules</a></li>
<li><a href="loaders.html">Loaders</a></li>
<li><a href="plugins.html">Plugins</a></li>
<li><a href="context.html">Context</a></li>
<li><a href="resolving.html">Resolving</a></li>
<li><a href="hot-module-replacement.html">Hot Module Replacement</a></li>
<li>开发工具<ul>
<li><a href="webpack-dev-server.html">webpack-dev-server</a></li>
<li><a href="webpack-dev-middleware.html">webpack-dev-middleware</a></li>
</ul>
</li>
</ul>
</li>
<li>Development<ul>
<li><a href="changelog.html">更新日志</a></li>
<li><a href="roadmap.html">路线图</a></li>
<li><a href="ideas.html">思路</a></li>
<li>贡献 (Contributing)</li>
</ul>
</li>
</ul>

					</div>
				</div>

				<div class="col-md-9">

					<div class="pull-right">
						<a href="https://github.com/XUEJS/webpack-docs/wiki/motivation/_edit" id="wikieditlink">Edit</a>
					</div>
					<div class="row">
						<div class="col-md-12 page-header">
							<h1 id="wikititle">motivation</h1>
						</div>
					</div>

					<div class="row">
						<div id="wiki" class="col-md-12">
							<div class="contents"><ul><li><a href="#module-system-styles">Module system styles</a><ul><li><a href="#script-tag-style"><code>&lt;script&gt;</code>-tag style</a></li><li><a href="#commonjs-synchronous-require">CommonJs: synchronous <code>require</code></a></li><li><a href="#amd-asynchronous-require">AMD: asynchronous require</a></li><li><a href="#es6-modules">ES6 modules</a></li><li><a href="#unbiased-solution">Unbiased solution</a></li></ul></li><li><a href="#transferring">Transferring</a><ul><li><a href="#chunked-transferring">Chunked transferring</a></li></ul></li><li><a href="#why-only-javascript">Why only JavaScript?</a></li><li><a href="#static-analysis">Static analysis</a><ul><li><a href="#strategy">Strategy</a></li></ul></li></ul></div><p>Today’s websites are evolving into web apps:</p>
<ul>
<li>More and more JavaScript is in a page.</li>
<li>You can do more stuff in modern browsers.</li>
<li>Fewer full page reloads → even more code in a page.</li>
</ul>
<p>As a result there is a <strong>lot</strong> of code on the client side!</p>
<p>A big code base needs to be organized. Module systems offer the option to split your code base into modules.</p>
<h1 id="module-system-styles"><a class="anchor" href="#module-system-styles">&rarr;</a>Module system styles</h1>
<p>There are multiple standards for how to define dependencies and export values:</p>
<ul>
<li><code>&lt;script&gt;</code>-tag style (without a module system)</li>
<li>CommonJs</li>
<li>AMD and some dialects of it</li>
<li>ES6 modules</li>
<li>and more…</li>
</ul>
<h2 id="script-tag-style"><a class="anchor" href="#script-tag-style">&rarr;</a><code>&lt;script&gt;</code>-tag style</h2>
<p>This is the way you would handle a modularized code base if you didn’t use a module system.</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"module1.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"module2.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"libraryA.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"module3.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre><p>Modules export an interface to the global object, i. e. the <code>window</code> object. Modules can access the interface of dependencies over the global object.</p>
<h4 id="common-problems"><a class="anchor" href="#common-problems">&rarr;</a>Common problems</h4>
<ul>
<li>Conflicts in the global object.</li>
<li>Order of loading is important.</li>
<li>Developers have to resolve dependencies of modules/libraries.</li>
<li>In big projects the list can get really long and difficult to manage.</li>
</ul>
<h2 id="commonjs-synchronous-require"><a class="anchor" href="#commonjs-synchronous-require">&rarr;</a>CommonJs: synchronous <code>require</code></h2>
<p>This style uses a synchronous <code>require</code> method to load a dependency and return an exported interface. A module can specify exports by adding properties to the <code>exports</code> object or setting the value of <code>module.exports</code>.</p>
<pre><code>require(<span class="string">"module"</span>);
require(<span class="string">"../file.js"</span>);
exports.doStuff = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>};
module.exports = someValue;</code></pre><p>It’s used on server-side by <a href="http://nodejs.org">node.js</a>.</p>
<h4 id="pros"><a class="anchor" href="#pros">&rarr;</a>Pros</h4>
<ul>
<li>Server-side modules can be reused</li>
<li>There are already many modules in this style (npm)</li>
<li>very simple and easy to use.</li>
</ul>
<h4 id="cons"><a class="anchor" href="#cons">&rarr;</a>Cons</h4>
<ul>
<li>blocking calls do not apply well on networks. Network requests are asynchronous.</li>
<li>No parallel require of multiple modules</li>
</ul>
<h4 id="implementations"><a class="anchor" href="#implementations">&rarr;</a>Implementations</h4>
<ul>
<li><a href="http://nodejs.org/">node.js</a> - server-side</li>
<li><a href="https://github.com/substack/node-browserify">browserify</a></li>
<li><a href="https://github.com/medikoo/modules-webmake">modules-webmake</a> - compile to one bundle</li>
<li><a href="https://github.com/substack/wreq">wreq</a> - client-side</li>
</ul>
<h2 id="amd-asynchronous-require"><a class="anchor" href="#amd-asynchronous-require">&rarr;</a>AMD: asynchronous require</h2>
<p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD"><code>Asynchronous Module Definition</code></a></p>
<p>Other module systems (for the browser) had problems with the synchronous <code>require</code> (CommonJs) and introduced an asynchronous version (and a way to define modules and exporting values):</p>
<pre><code>require([<span class="string">"module"</span>, <span class="string">"../file"</span>], <span class="function"><span class="keyword">function</span><span class="params">(module, file)</span> {</span> <span class="comment">/* ... */</span> });
define(<span class="string">"mymodule"</span>, [<span class="string">"dep1"</span>, <span class="string">"dep2"</span>], <span class="function"><span class="keyword">function</span><span class="params">(d1, d2)</span> {</span>
  <span class="keyword">return</span> someExportedValue;
});</code></pre><h4 id="pros"><a class="anchor" href="#pros">&rarr;</a>Pros</h4>
<ul>
<li>Fits to the asynchronous request style in networks.</li>
<li>Parallel loading of multiple modules.</li>
</ul>
<h4 id="cons"><a class="anchor" href="#cons">&rarr;</a>Cons</h4>
<ul>
<li>Coding overhead. More difficult to read and write.</li>
<li>Seems to be some kind of workaround.</li>
</ul>
<h4 id="implementations"><a class="anchor" href="#implementations">&rarr;</a>Implementations</h4>
<ul>
<li><a href="http://requirejs.org/">require.js</a> - client-side</li>
<li><a href="https://github.com/cujojs/curl">curl</a> - client-side</li>
</ul>
<p>Read more about <a href="commonjs.html">CommonJs</a> and <a href="amd.html">AMD</a>.</p>
<h2 id="es6-modules"><a class="anchor" href="#es6-modules">&rarr;</a>ES6 modules</h2>
<p>EcmaScript6 adds some language constructs to JavaScript, which form another module system.</p>
<pre><code>import <span class="string">"jquery"</span>;
export <span class="function"><span class="keyword">function</span> <span class="title">doStuff</span><span class="params">()</span> {</span>}
module <span class="string">"localModule"</span> {}</code></pre><h4 id="pros"><a class="anchor" href="#pros">&rarr;</a>Pros</h4>
<ul>
<li>Static analysis is easy</li>
<li>Future-proof as ES standard</li>
</ul>
<h4 id="cons"><a class="anchor" href="#cons">&rarr;</a>Cons</h4>
<ul>
<li>Native browser support will take time</li>
<li>Very few modules in this style</li>
</ul>
<h2 id="unbiased-solution"><a class="anchor" href="#unbiased-solution">&rarr;</a>Unbiased solution</h2>
<p>Give the developer the choice of the module style. Allow existing code to work. Make it easy to add custom module styles.</p>
<hr>
<h1 id="transferring"><a class="anchor" href="#transferring">&rarr;</a>Transferring</h1>
<p>Modules should be executed on the client, so they must be transferred from the server to the browser.</p>
<p>There are two extremes on how to transfer modules:</p>
<ul>
<li>1 request per module</li>
<li>all modules in one request</li>
</ul>
<p>Both are used in the wild, but both are suboptimal:</p>
<ul>
<li>1 request per module<ul>
<li>Pro: only required modules are transferred</li>
<li>Con: many requests means much overhead</li>
<li>Con: slow application startup, because of request latency</li>
</ul>
</li>
<li>all modules in one request<ul>
<li>Pro: less request overhead, less latency</li>
<li>Con: not (yet) required modules are transferred too</li>
</ul>
</li>
</ul>
<h2 id="chunked-transferring"><a class="anchor" href="#chunked-transferring">&rarr;</a>Chunked transferring</h2>
<p>A more flexible transferring would be better. A compromise between the extremes is better in most cases.</p>
<p>→ While compiling all modules: Split the set of modules into multiple smaller batches (chunks).</p>
<p>We get multiple smaller requests. Chunks with modules that are not required initially are only requested on demand. The initial request doesn’t contain your complete code base and is smaller.</p>
<p>The “split points” are up to the developer and optional.</p>
<p>→ A big code base is possible!</p>
<p>Note: The <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideCodeSplitting">idea is from Google’s GWT</a>. </p>
<p>Read more about <a href="code-splitting.html">Code Splitting</a>.</p>
<hr>
<h1 id="why-only-javascript"><a class="anchor" href="#why-only-javascript">&rarr;</a>Why only JavaScript?</h1>
<p>Why should a module system only help the developer with JavaScript? There are many other static resources that need to be handled:</p>
<ul>
<li>stylesheets</li>
<li>images</li>
<li>webfonts</li>
<li>html for templating</li>
<li>etc.</li>
</ul>
<p>And also:</p>
<ul>
<li>coffeescript → javascript</li>
<li>less stylesheets → css stylesheets</li>
<li>jade templates → javascript which generates html</li>
<li>i18n files → something</li>
<li>etc.</li>
</ul>
<p>This should be as easy as:</p>
<pre><code>require(<span class="string">"./style.css"</span>);</code></pre><pre><code>require(<span class="string">"./style.less"</span>);
require(<span class="string">"./template.jade"</span>);
require(<span class="string">"./image.png"</span>);</code></pre><p>Read more about <a href="using-loaders.html">Using loaders</a> and <a href="loaders.html">Loaders</a>.</p>
<hr>
<h1 id="static-analysis"><a class="anchor" href="#static-analysis">&rarr;</a>Static analysis</h1>
<p>When compiling all the modules a static analysis tries to find dependencies.</p>
<p>Traditionally this could only find simple stuff without expression, but i.e. <code>require(<span class="string">"./template/"</span> + templateName + <span class="string">".jade"</span>)</code> is a common construct.</p>
<p>Many libraries are written in different styles. Some of them are very weird…</p>
<h2 id="strategy"><a class="anchor" href="#strategy">&rarr;</a>Strategy</h2>
<p>A clever parser would allow most existing code to run. If the developer does something weird it would try to find the most compatible solution.</p>

						</div>
					</div>

					<div class="row">
						<div class="col-md-12">
							<div id="disqus_thread"></div>
						</div>
					</div>
				</div>

			</div>
		</div>
		<a href="https://github.com/webpack/webpack"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png" alt="Fork me on GitHub"></a>
	</body>
</html>