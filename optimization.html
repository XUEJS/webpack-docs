<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description" content="">
		<meta name="author" content="">
		<link rel="icon" type="image/png" href="/assets/favicon.png" />
		<link rel="stylesheet" href="css/doc.css" />
		<title>optimization</title>
	</head>
	<body>
		<script src="js/doc.js" charset="utf-8" async></script>
		<div class="container">
			<div class="row">
				<div class="col-md-3 nav">

					<div class="logo">
	<ul class="cube-inner">
		<li class="front"><li class="back"><li class="right"><li class="left"><li class="top"><li class="bottom">
	</ul>
	<ul class="cube">
		<li class="front"><li class="back"><li class="right"><li class="left"><li class="top"><li class="bottom">
		<li class="floor">
	</ul>
</div>
<div class="name">webpack</div>
<div class="tagline">MODULE BUNDLER</div>


					<div class="sidebar">
						<ul><li><a href=".">Home</a></li></ul>
						<ul>
<li>入门<ul>
<li><a href="motivation.html">动机</a></li>
<li><a href="what-is-webpack.html">什么是的WebPack？</a></li>
<li><a href="installation.html">安装</a></li>
<li><a href="usage.html">用法</a></li>
<li>Require Modules</li>
<li>Vendor Modules</li>
<li><a href="using-loaders.html">使用加载器</a></li>
<li><a href="using-plugins.html">使用插件</a></li>
<li><a href="dev-tools.html">开发工具</a></li>
<li><a href="troubleshooting.html">故障排除</a></li>
</ul>
</li>
<li>教程与示例<ul>
<li><a href="http://webpack.github.io/docs/tutorials/getting-started/">入门</a></li>
<li><a href="list-of-tutorials.html">教程列表</a></li>
<li><a href="examples.html">示例</a></li>
</ul>
</li>
<li>指南<ul>
<li><a href="commonjs.html">CommonJs</a></li>
<li><a href="amd.html">AMD</a></li>
<li><a href="webpack-for-browserify-users.html">Browserify 用户</a></li>
<li><a href="code-splitting.html">代码分割</a></li>
<li><a href="stylesheets.html">样式表</a></li>
<li><a href="optimization.html">优化</a></li>
<li><a href="long-term-caching.html">长期缓存</a></li>
<li><a href="how-to-write-a-loader.html">如何写一个加载器</a></li>
<li>如何写一个插件(How to write a plugin)</li>
<li><a href="multiple-entry-points.html">多个入口点</a>(Multiple entry points)</li>
<li><a href="library-and-externals.html">库和扩展</a>(Library and externals)</li>
<li><a href="shimming-modules.html">垫片模块</a>(Shimming modules)</li>
<li><a href="testing.html">测试</a></li>
<li><a href="build-performance.html">构建性能</a></li>
<li><a href="hot-module-replacement-with-webpack.html">模块热替换</a>(Hot Module Replacement with webpack)</li>
<li><a href="comparison.html">比较</a></li>
</ul>
</li>
<li>webpack 相关<ul>
<li><a href="usage-with-grunt.html">使用 Grunt</a></li>
<li><a href="usage-with-gulp.html">使用 Gulp</a></li>
<li><a href="usage-with-bower.html">使用 Bower</a></li>
<li><a href="usage-with-karma.html">使用 Karma</a></li>
</ul>
</li>
<li>列表<ul>
<li><a href="loader-conventions.html">加载器约定</a></li>
<li><a href="list-of-loaders.html">加载器列表</a></li>
<li><a href="list-of-plugins.html">插件列表</a></li>
<li><a href="list-of-tutorials.html">教程列表</a></li>
</ul>
</li>
<li>API<ul>
<li><a href="configuration.html">构造</a></li>
<li><a href="cli.html">CLI</a></li>
<li><a href="node.js-api.html">Node.js API</a></li>
<li><a href="api-in-modules.html">API in modules</a></li>
<li><a href="loaders.html">Loaders</a></li>
<li><a href="plugins.html">Plugins</a></li>
<li><a href="context.html">Context</a></li>
<li><a href="resolving.html">Resolving</a></li>
<li><a href="hot-module-replacement.html">Hot Module Replacement</a></li>
<li>开发工具<ul>
<li><a href="webpack-dev-server.html">webpack-dev-server</a></li>
<li><a href="webpack-dev-middleware.html">webpack-dev-middleware</a></li>
</ul>
</li>
</ul>
</li>
<li>Development<ul>
<li><a href="changelog.html">更新日志</a></li>
<li><a href="roadmap.html">路线图</a></li>
<li><a href="ideas.html">思路</a></li>
<li>贡献 (Contributing)</li>
</ul>
</li>
</ul>

					</div>
				</div>

				<div class="col-md-9">

					<div class="pull-right">
						<a href="https://github.com/XUEJS/webpack-docs/wiki/optimization/_edit" id="wikieditlink">Edit</a>
					</div>
					<div class="row">
						<div class="col-md-12 page-header">
							<h1 id="wikititle">optimization</h1>
						</div>
					</div>

					<div class="row">
						<div id="wiki" class="col-md-12">
							<div class="contents"><ul><li><a href="#minimize">Minimize</a></li><li><a href="#deduplication">Deduplication</a></li><li><a href="#chunks">Chunks</a></li><li><a href="#single-page-app">Single-Page-App</a></li><li><a href="#multi-page-app">Multi-Page-App</a></li></ul></li></ul></div><h2 id="minimize"><a class="anchor" href="#minimize">&rarr;</a>Minimize</h2>
<p>To minimize your scripts (and your css, if you use the css-loader) webpack supports a simple option:</p>
<p><code>--optimize-minimize</code> resp. <a href="http://webpack.github.io/docs/list-of-plugins.html#uglifyjsplugin"><code><span class="keyword">new</span> webpack.optimize.UglifyJsPlugin()</code></a></p>
<p>That’s a simple but effective way to optimize your web app.</p>
<p>As you already know (if you’ve read the remaining docs) webpack gives your modules and chunks ids to identify them. Webpack can vary the distribution of the ids to get the smallest id length for often used ids with a simple option:</p>
<p><code>--optimize-occurence-order</code> resp. <code><span class="keyword">new</span> webpack.optimize.OccurenceOrderPlugin()</code></p>
<p>The entry chunks have higher priority for file size.</p>
<h2 id="deduplication"><a class="anchor" href="#deduplication">&rarr;</a>Deduplication</h2>
<p>If you use some libraries with cool dependency trees, it may occur that some files are identical. Webpack can find these files and deduplicate them. This prevents the inclusion of duplicate code into your bundle and instead applies a copy of the function at runtime. It doesn’t affect semantics. You can enable it with:</p>
<p><code>--optimize-dedupe</code> resp. <code><span class="keyword">new</span> webpack.optimize.DedupePlugin()</code></p>
<p>This feature adds some overhead to the entry chunk.</p>
<h2 id="chunks"><a class="anchor" href="#chunks">&rarr;</a>Chunks</h2>
<p>While writing your code, you may have already added many code split points to load stuff on demand. After compiling you might notice that there are too many chunks that are too small - creating larger HTTP overhead. Luckily, Webpack can post-process your chunks by merging them. You can provide two options:</p>
<ul>
<li>Limit the maximum chunk count with <code>--optimize-max-chunks <span class="number">15</span></code> <code><span class="keyword">new</span> webpack.optimize.LimitChunkCountPlugin({maxChunks: <span class="number">15</span>})</code></li>
<li>Limit the minimum chunk size with <code>--optimize-min-chunk-size <span class="number">10000</span></code> <code><span class="keyword">new</span> webpack.optimize.MinChunkSizePlugin({minChunkSize: <span class="number">10000</span>})</code></li>
</ul>
<p>Webpack will take care of it by merging chunks (it will prefer merging chunk that have duplicate modules). Nothing will be merged into the entry chunk, so as not to impact initial page loading time.</p>
<h2 id="single-page-app"><a class="anchor" href="#single-page-app">&rarr;</a>Single-Page-App</h2>
<p>A Single-Page-App is the type of web app webpack is designed and optimized for.</p>
<p>You may have split the app into multiple chunks, which are loaded at your router. The entry chunk only contains the router and some libraries, but no content. This works great while your user is navigating through your app, but for initial page load you need 2 round trips: One for the router and one for the current content page.</p>
<p>If you use the HTML5 History API to reflect the current content page in the URL, your server can know which content page will be requested by the client code. To save round trips the server can include the content chunk in the response: This is possible by just adding it as script tag. The browser will load both chunks parallel.</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"entry-chunk.js"</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"3.chunk.js"</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre><p>You can extract the chunk filename from the stats.</p>
<h2 id="multi-page-app"><a class="anchor" href="#multi-page-app">&rarr;</a>Multi-Page-App</h2>
<p>When you compile a (real) multi page app, you want to share common code between the pages. In fact this is really easy with webpack: Just compile with multiple entry points:</p>
<p><code>webpack p1=.<span class="regexp">/page1 p2=./</span>page2 p3=.<span class="regexp">/page3 [name].entry-chunk.js</span></code></p>
<pre><code>module.exports = {
    entry: {
        p1: <span class="string">"./page1"</span>,
        p2: <span class="string">"./page2"</span>,
        p3: <span class="string">"./page3"</span>
    },
    output: {
        filename: <span class="string">"[name].entry.chunk.js"</span>
    }
}</code></pre><p>This will generate multiple entry chunks: <code>p1.entry.chunk.js</code>, <code>p2.entry.chunk.js</code> and <code>p3.entry.chunk.js</code>. But additional chunks can be shared by them.</p>
<p>If your entry chunks have some modules in common, there is a cool plugin for this. The <code>CommonsChunkPlugin</code> identifies common modules and put them into a commons chunk. You need to add two script tags to your page, one for the commons chunk and one for the entry chunk.</p>
<pre><code><span class="keyword">var</span> CommonsChunkPlugin = require(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);
module.exports = {
    entry: {
        p1: <span class="string">"./page1"</span>,
        p2: <span class="string">"./page2"</span>,
        p3: <span class="string">"./page3"</span>
    },
    output: {
        filename: <span class="string">"[name].entry.chunk.js"</span>
    },
    plugins: [
        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons.chunk.js"</span>)
    ]
}</code></pre><p>This will generate multiple entry chunks: <code>p1.entry.chunk.js</code>, <code>p2.entry.chunk.js</code> and <code>p3.entry.chunk.js</code>, plus one <code>commons.chunk.js</code>. First load <code>commons.chunk.js</code> and than one of the <code>xx.entry.chunk.js</code>.</p>
<p>You can generate multiple commons chunks, by selecting the entry chunks. And you can nest commons chunks.</p>
<pre><code><span class="keyword">var</span> CommonsChunkPlugin = require(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);
module.exports = {
    entry: {
        p1: <span class="string">"./page1"</span>,
        p2: <span class="string">"./page2"</span>,
        p3: <span class="string">"./page3"</span>,
        ap1: <span class="string">"./admin/page1"</span>,
        ap2: <span class="string">"./admin/page2"</span>
    },
    output: {
        filename: <span class="string">"[name].js"</span>
    },
    plugins: [
        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"admin-commons.js"</span>, [<span class="string">"ap1"</span>, <span class="string">"ap2"</span>]),
        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons.js"</span>, [<span class="string">"p1"</span>, <span class="string">"p2"</span>, <span class="string">"admin-commons.js"</span>])
    ]
};
<span class="comment">// &lt;script&gt;s required:</span>
<span class="comment">// page1.html: commons.js, p1.js</span>
<span class="comment">// page2.html: commons.js, p2.js</span>
<span class="comment">// page3.html: p3.js</span>
<span class="comment">// admin-page1.html: commons.js, admin-commons.js, ap1.js</span>
<span class="comment">// admin-page2.html: commons.js, admin-commons.js, ap2.js</span></code></pre><p>Advanced hint: You can run code inside the commons chunk:</p>
<pre><code><span class="keyword">var</span> CommonsChunkPlugin = require(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);
module.exports = {
    entry: {
        p1: <span class="string">"./page1"</span>,
        p2: <span class="string">"./page2"</span>,
        commons: <span class="string">"./entry-for-the-commons-chunk"</span>
    },
    plugins: [
        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons"</span>, <span class="string">"commons.js"</span>)
    ]
};</code></pre><p>See also <a href="https://github.com/webpack/webpack/tree/master/examples/multiple-entry-points">multiple-entry-points example</a> and <a href="https://github.com/webpack/webpack/tree/master/examples/multiple-commons-chunks">advanced multiple-commons-chunks example</a>.</p>

						</div>
					</div>

					<div class="row">
						<div class="col-md-12">
							<div id="disqus_thread"></div>
						</div>
					</div>
				</div>

			</div>
		</div>
		<a href="https://github.com/webpack/webpack"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png" alt="Fork me on GitHub"></a>
	</body>
</html>